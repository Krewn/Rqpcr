container[[k+1]] <- paste(temp223, thingy[[k]])
}
writeLines(LOLprint(container), "test2.ddv")
}
m5(q)
flag <- 0
m5 <- function(data1){
temp2 <- list()
Efficiency <- list() #Efficiency, Linear regression fitted on log of F in a window of 4 cycles, that delivers the least sigma(E) between reactions per amplicon
Eff <- list() #amplification efficiency
F0 <- list() #initial fluo. at x=0, F0 = (Fq)/(E^(Cq))
Fq <- list() #Fluo. at Cq
Cq <- list() #Quantification cycle, One cycle below the top border  of the best window of cycles
for(k in 2:length(data1)) { #calculates efficiency for each cycle, which is fold increase in PCR product per cycle
Eff[[k-1]] <- list()
for(k2 in 2:length(data1[[k]])) {
Eff[[k-1]][[k2-1]] <- (data1[[k]][[k2]])/(data1[[k]][[k2-1]])
}
print(k)
}
for(k in 1:length(Eff)) {
Efficiency[[k]] <- sDeviation(Eff[[k]], 4)
temp2[[k]] <-
print(Efficiency[[k]])
}
for(k in 1:length(Efficiency)) {
F0[[k]] <- as.integer(data1[[k]][[flag[[k]]]])/(as.integer(Efficiency[[k]]^flag[[k]]))
}
printSHIT(F0)
#   for(k in 1:11) {
#        print(F0[[k]])
#   }
#      printSHIT(F0)
#   for(k in 1:length(Cq)) { #Assigns values to Fluo. at cycle Cq
#        Fq[[k]] <- norms[[k+1]][[Cq]]
#   }
#
#   for(k in 1:length(Cq)) { calculates the initial fluo.
#        F0[[k]] <- (Fq[[k]])/(Efficiency[[k]]^Cq[[k]])
#   }
}
sDeviation <- function(values, width) {
tst <- 10000000
E1 <-0
for(k in 1:(length(values)-3)) {
flag <- 3
val <- list()
for(k2 in 1:width) {
temp3 <- k+k2-1
val[[k2]] <- values[[temp3]]
}
val <- as.vector(val, "numeric")
if(sd(val) < tst) {
flag <- val[3]
tst <- sd(val)
E1 <- mean(val)
}
}
return(E1)
}
printSHIT <- function(thingy) {
container <- list()
for(k in 1:length(thingy)) {
temp223 <- paste(gd[[1]][[2]][[k+1]][1], gd[[1]][[2]][[k+1]][2])
container[[k+1]] <- paste(temp223, thingy[[k]])
}
writeLines(LOLprint(container), "test2.ddv")
}
m5(q)
flag <- 0
m5 <- function(data1){
temp2 <- list()
Efficiency <- list() #Efficiency, Linear regression fitted on log of F in a window of 4 cycles, that delivers the least sigma(E) between reactions per amplicon
Eff <- list() #amplification efficiency
F0 <- list() #initial fluo. at x=0, F0 = (Fq)/(E^(Cq))
Fq <- list() #Fluo. at Cq
Cq <- list() #Quantification cycle, One cycle below the top border  of the best window of cycles
for(k in 2:length(data1)) { #calculates efficiency for each cycle, which is fold increase in PCR product per cycle
Eff[[k-1]] <- list()
for(k2 in 2:length(data1[[k]])) {
Eff[[k-1]][[k2-1]] <- (data1[[k]][[k2]])/(data1[[k]][[k2-1]])
}
print(k)
}
for(k in 1:length(Eff)) {
Efficiency[[k]] <- sDeviation(Eff[[k]], 4)
temp2[[k]] <-
print(Efficiency[[k]])
}
for(k in 1:length(Efficiency)) {
F0[[k]] <- as.integer(data1[[k]][[flag])/(as.integer(Efficiency[[k]]^flag))
}
printSHIT(F0)
#   for(k in 1:11) {
#        print(F0[[k]])
#   }
#      printSHIT(F0)
#   for(k in 1:length(Cq)) { #Assigns values to Fluo. at cycle Cq
#        Fq[[k]] <- norms[[k+1]][[Cq]]
#   }
#
#   for(k in 1:length(Cq)) { calculates the initial fluo.
#        F0[[k]] <- (Fq[[k]])/(Efficiency[[k]]^Cq[[k]])
#   }
}
sDeviation <- function(values, width) {
tst <- 10000000
E1 <-0
for(k in 1:(length(values)-3)) {
flag <- 3
val <- list()
for(k2 in 1:width) {
temp3 <- k+k2-1
val[[k2]] <- values[[temp3]]
}
val <- as.vector(val, "numeric")
if(sd(val) < tst) {
flag <- val[3]
tst <- sd(val)
E1 <- mean(val)
}
}
return(E1)
}
printSHIT <- function(thingy) {
container <- list()
for(k in 1:length(thingy)) {
temp223 <- paste(gd[[1]][[2]][[k+1]][1], gd[[1]][[2]][[k+1]][2])
container[[k+1]] <- paste(temp223, thingy[[k]])
}
writeLines(LOLprint(container), "test2.ddv")
}
m5(q)
flag <- 0
m5 <- function(data1){
temp2 <- list()
Efficiency <- list() #Efficiency, Linear regression fitted on log of F in a window of 4 cycles, that delivers the least sigma(E) between reactions per amplicon
Eff <- list() #amplification efficiency
F0 <- list() #initial fluo. at x=0, F0 = (Fq)/(E^(Cq))
Fq <- list() #Fluo. at Cq
Cq <- list() #Quantification cycle, One cycle below the top border  of the best window of cycles
for(k in 2:length(data1)) { #calculates efficiency for each cycle, which is fold increase in PCR product per cycle
Eff[[k-1]] <- list()
for(k2 in 2:length(data1[[k]])) {
Eff[[k-1]][[k2-1]] <- (data1[[k]][[k2]])/(data1[[k]][[k2-1]])
}
print(k)
}
for(k in 1:length(Eff)) {
Efficiency[[k]] <- sDeviation(Eff[[k]], 4)
temp2[[k]] <-
print(Efficiency[[k]])
}
for(k in 1:length(Efficiency)) {
F0[[k]] <- as.integer(data1[[k]][[flag]])/(as.integer(Efficiency[[k]]^flag))
}
printSHIT(F0)
#   for(k in 1:11) {
#        print(F0[[k]])
#   }
#      printSHIT(F0)
#   for(k in 1:length(Cq)) { #Assigns values to Fluo. at cycle Cq
#        Fq[[k]] <- norms[[k+1]][[Cq]]
#   }
#
#   for(k in 1:length(Cq)) { calculates the initial fluo.
#        F0[[k]] <- (Fq[[k]])/(Efficiency[[k]]^Cq[[k]])
#   }
}
sDeviation <- function(values, width) {
tst <- 10000000
E1 <-0
for(k in 1:(length(values)-3)) {
flag <- 3
val <- list()
for(k2 in 1:width) {
temp3 <- k+k2-1
val[[k2]] <- values[[temp3]]
}
val <- as.vector(val, "numeric")
if(sd(val) < tst) {
flag <- val[3]
tst <- sd(val)
E1 <- mean(val)
}
}
return(E1)
}
printSHIT <- function(thingy) {
container <- list()
for(k in 1:length(thingy)) {
temp223 <- paste(gd[[1]][[2]][[k+1]][1], gd[[1]][[2]][[k+1]][2])
container[[k+1]] <- paste(temp223, thingy[[k]])
}
writeLines(LOLprint(container), "test2.ddv")
}
m5(q)
m5 <- function(data1){
temp2 <- list()
Efficiency <- list() #Efficiency, Linear regression fitted on log of F in a window of 4 cycles, that delivers the least sigma(E) between reactions per amplicon
Eff <- list() #amplification efficiency
F0 <- list() #initial fluo. at x=0, F0 = (Fq)/(E^(Cq))
Fq <- list() #Fluo. at Cq
Cq <- list() #Quantification cycle, One cycle below the top border  of the best window of cycles
for(k in 2:length(data1)) { #calculates efficiency for each cycle, which is fold increase in PCR product per cycle
Eff[[k-1]] <- list()
for(k2 in 2:length(data1[[k]])) {
Eff[[k-1]][[k2-1]] <- (data1[[k]][[k2]])/(data1[[k]][[k2-1]])
}
print(k)
}
for(k in 1:length(Eff)) {
Efficiency[[k]] <- sDeviation(Eff[[k]], 4)
temp2[[k]] <-
print(Efficiency[[k]])
}
for(k in 1:length(Efficiency)) {
F0[[k]] <- as.integer(data1[[k]][[Cq[[k]]]])/(as.integer(Efficiency[[k]]^Cq[[k]]))
}
printSHIT(F0)
#   for(k in 1:11) {
#        print(F0[[k]])
#   }
#      printSHIT(F0)
#   for(k in 1:length(Cq)) { #Assigns values to Fluo. at cycle Cq
#        Fq[[k]] <- norms[[k+1]][[Cq]]
#   }
#
#   for(k in 1:length(Cq)) { calculates the initial fluo.
#        F0[[k]] <- (Fq[[k]])/(Efficiency[[k]]^Cq[[k]])
#   }
}
sDeviation <- function(values, width) {
tst <- 10000000
E1 <-0
for(k in 1:(length(values)-3)) {
Cq[[k]] <- 3
val <- list()
for(k2 in 1:width) {
temp3 <- k+k2-1
val[[k2]] <- values[[temp3]]
}
val <- as.vector(val, "numeric")
if(sd(val) < tst) {
Cq[[k]] <- val[3]
tst <- sd(val)
E1 <- mean(val)
}
}
return(E1)
}
printSHIT <- function(thingy) {
container <- list()
for(k in 1:length(thingy)) {
temp223 <- paste(gd[[1]][[2]][[k+1]][1], gd[[1]][[2]][[k+1]][2])
container[[k+1]] <- paste(temp223, thingy[[k]])
}
writeLines(LOLprint(container), "test2.ddv")
}
m5(q)
m5 <- function(data1){
temp2 <- list()
Efficiency <- list() #Efficiency, Linear regression fitted on log of F in a window of 4 cycles, that delivers the least sigma(E) between reactions per amplicon
Eff <- list() #amplification efficiency
F0 <- list() #initial fluo. at x=0, F0 = (Fq)/(E^(Cq))
Fq <- list() #Fluo. at Cq
Cq <- list() #Quantification cycle, One cycle below the top border  of the best window of cycles
for(k in 2:length(data1)) { #calculates efficiency for each cycle, which is fold increase in PCR product per cycle
Eff[[k-1]] <- list()
for(k2 in 2:length(data1[[k]])) {
Eff[[k-1]][[k2-1]] <- (data1[[k]][[k2]])/(data1[[k]][[k2-1]])
}
print(k)
}
for(k in 1:length(Eff)) {
Efficiency[[k]] <- sDeviation(Eff[[k]], 4)
temp2[[k]] <-
print(Efficiency[[k]])
}
for(k in 1:length(Efficiency)) {
F0[[k]] <- as.integer(data1[[k]][[Cq[[k]]]])/(as.integer(Efficiency[[k]]^Cq[[k]]))
}
printSHIT(F0)
#   for(k in 1:11) {
#        print(F0[[k]])
#   }
#      printSHIT(F0)
#   for(k in 1:length(Cq)) { #Assigns values to Fluo. at cycle Cq
#        Fq[[k]] <- norms[[k+1]][[Cq]]
#   }
#
#   for(k in 1:length(Cq)) { calculates the initial fluo.
#        F0[[k]] <- (Fq[[k]])/(Efficiency[[k]]^Cq[[k]])
#   }
}
sDeviation <- function(values, width) {
tst <- 10000000
E1 <-0
for(k in 1:(length(values)-3)) {
Cq[[k]] <- 3
val <- list()
for(k2 in 1:width) {
temp3 <- k+k2-1
val[[k2]] <- values[[temp3]]
}
val <- as.vector(val, "numeric")
if(sd(val) < tst) {
Cq[[k]] <- k+2
tst <- sd(val)
E1 <- mean(val)
}
}
return(E1)
}
printSHIT <- function(thingy) {
container <- list()
for(k in 1:length(thingy)) {
temp223 <- paste(gd[[1]][[2]][[k+1]][1], gd[[1]][[2]][[k+1]][2])
container[[k+1]] <- paste(temp223, thingy[[k]])
}
writeLines(LOLprint(container), "test2.ddv")
}
m5(q)
temp2 <- list()
m5 <- function(data1){
Efficiency <- list() #Efficiency, Linear regression fitted on log of F in a window of 4 cycles, that delivers the least sigma(E) between reactions per amplicon
Eff <- list() #amplification efficiency
F0 <- list() #initial fluo. at x=0, F0 = (Fq)/(E^(Cq))
Fq <- list() #Fluo. at Cq
Cq <- 0 #Quantification cycle, One cycle below the top border  of the best window of cycles
for(k in 2:length(data1)) { #calculates efficiency for each cycle, which is fold increase in PCR product per cycle
Eff[[k-1]] <- list()
for(k2 in 2:length(data1[[k]])) {
Eff[[k-1]][[k2-1]] <- (data1[[k]][[k2]])/(data1[[k]][[k2-1]])
}
print(k)
}
for(k in 1:length(Eff)) {
Efficiency[[k]] <- sDeviation(Eff[[k]], 4)
temp2[[k]] <- Cq
print(Efficiency[[k]])
}
for(k in 1:length(Efficiency)) {
F0[[k]] <- as.integer(data1[[k]][[temp2[[k]])/(as.integer(Efficiency[[k]]^temp2[[k]]))
}
printSHIT(F0)
#   for(k in 1:11) {
#        print(F0[[k]])
#   }
#      printSHIT(F0)
#   for(k in 1:length(Cq)) { #Assigns values to Fluo. at cycle Cq
#        Fq[[k]] <- norms[[k+1]][[Cq]]
#   }
#
#   for(k in 1:length(Cq)) { calculates the initial fluo.
#        F0[[k]] <- (Fq[[k]])/(Efficiency[[k]]^Cq[[k]])
#   }
}
sDeviation <- function(values, width) {
tst <- 10000000
E1 <-0
for(k in 1:(length(values)-3)) {
Cq <- 3
val <- list()
for(k2 in 1:width) {
temp3 <- k+k2-1
val[[k2]] <- values[[temp3]]
}
val <- as.vector(val, "numeric")
if(sd(val) < tst) {
Cq <- k+2
tst <- sd(val)
E1 <- mean(val)
}
}
return(E1)
}
printSHIT <- function(thingy) {
container <- list()
for(k in 1:length(thingy)) {
temp223 <- paste(gd[[1]][[2]][[k+1]][1], gd[[1]][[2]][[k+1]][2])
container[[k+1]] <- paste(temp223, thingy[[k]])
}
writeLines(LOLprint(container), "test2.ddv")
}
m5(q)
temp2 <- list()
m5 <- function(data1){
Efficiency <- list() #Efficiency, Linear regression fitted on log of F in a window of 4 cycles, that delivers the least sigma(E) between reactions per amplicon
Eff <- list() #amplification efficiency
F0 <- list() #initial fluo. at x=0, F0 = (Fq)/(E^(Cq))
Fq <- list() #Fluo. at Cq
Cq <- 0 #Quantification cycle, One cycle below the top border  of the best window of cycles
for(k in 2:length(data1)) { #calculates efficiency for each cycle, which is fold increase in PCR product per cycle
Eff[[k-1]] <- list()
for(k2 in 2:length(data1[[k]])) {
Eff[[k-1]][[k2-1]] <- (data1[[k]][[k2]])/(data1[[k]][[k2-1]])
}
print(k)
}
for(k in 1:length(Eff)) {
Efficiency[[k]] <- sDeviation(Eff[[k]], 4)
temp2[[k]] <- Cq
print(Efficiency[[k]])
}
for(k in 1:length(Efficiency)) {
F0[[k]] <- as.integer(data1[[k]][[temp2[[k]])/(as.integer(Efficiency[[k]]^temp2[[k]]))
}
printSHIT(F0)
#   for(k in 1:11) {
#        print(F0[[k]])
#   }
#      printSHIT(F0)
#   for(k in 1:length(Cq)) { #Assigns values to Fluo. at cycle Cq
#        Fq[[k]] <- norms[[k+1]][[Cq]]
#   }
#
#   for(k in 1:length(Cq)) { calculates the initial fluo.
#        F0[[k]] <- (Fq[[k]])/(Efficiency[[k]]^Cq[[k]])
#   }
}
sDeviation <- function(values, width) {
tst <- 10000000
E1 <-0
for(k in 1:(length(values)-3)) {
Cq <- 3
val <- list()
for(k2 in 1:width) {
temp3 <- k+k2-1
val[[k2]] <- values[[temp3]]
}
val <- as.vector(val, "numeric")
if(sd(val) < tst) {
Cq <- k+2
tst <- sd(val)
E1 <- mean(val)
}
}
return(E1)
}
printSHIT <- function(thingy) {
container <- list()
for(k in 1:length(thingy)) {
temp223 <- paste(gd[[1]][[2]][[k+1]][1], gd[[1]][[2]][[k+1]][2])
container[[k+1]] <- paste(temp223, thingy[[k]])
}
writeLines(LOLprint(container), "test2.ddv")
}
m5(q)
temp2 <- list()
m5 <- function(data1){
Efficiency <- list() #Efficiency, Linear regression fitted on log of F in a window of 4 cycles, that delivers the least sigma(E) between reactions per amplicon
Eff <- list() #amplification efficiency
F0 <- list() #initial fluo. at x=0, F0 = (Fq)/(E^(Cq))
Fq <- list() #Fluo. at Cq
Cq <- 0 #Quantification cycle, One cycle below the top border  of the best window of cycles
for(k in 2:length(data1)) { #calculates efficiency for each cycle, which is fold increase in PCR product per cycle
Eff[[k-1]] <- list()
for(k2 in 2:length(data1[[k]])) {
Eff[[k-1]][[k2-1]] <- (data1[[k]][[k2]])/(data1[[k]][[k2-1]])
}
print(k)
}
for(k in 1:length(Eff)) {
Efficiency[[k]] <- sDeviation(Eff[[k]], 4)
temp2[[k]] <- Cq
print(Efficiency[[k]])
}
for(k in 1:length(Efficiency)) {
F0[[k]] <- as.integer(data1[[k]][[temp2[[k]])/(as.integer(Efficiency[[k]]^temp2[[k]]))
}
printSHIT(F0)
#   for(k in 1:11) {
#        print(F0[[k]])
#   }
#      printSHIT(F0)
#   for(k in 1:length(Cq)) { #Assigns values to Fluo. at cycle Cq
#        Fq[[k]] <- norms[[k+1]][[Cq]]
#   }
#
#   for(k in 1:length(Cq)) { calculates the initial fluo.
#        F0[[k]] <- (Fq[[k]])/(Efficiency[[k]]^Cq[[k]])
#   }
}
sDeviation <- function(values, width) {
tst <- 10000000
E1 <-0
for(k in 1:(length(values)-3)) {
Cq <- 3
val <- list()
for(k2 in 1:width) {
temp3 <- k+k2-1
val[[k2]] <- values[[temp3]]
}
val <- as.vector(val, "numeric")
if(sd(val) < tst) {
Cq <- (k+2)
tst <- sd(val)
E1 <- mean(val)
}
}
return(E1)
}
printSHIT <- function(thingy) {
container <- list()
for(k in 1:length(thingy)) {
temp223 <- paste(gd[[1]][[2]][[k+1]][1], gd[[1]][[2]][[k+1]][2])
container[[k+1]] <- paste(temp223, thingy[[k]])
}
writeLines(LOLprint(container), "test2.ddv")
}
m5(q)
